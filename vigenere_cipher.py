#INPUT_TEXT = "ENEEZCTIQPLKYTPURCJBCFIQTNSSFPQPWFEYLVSKYMCNBQJSMNRYKVCODRLOKKHYNYQMWXNGYFZYRRVKGYASCIWVTYEHEIGWGQDPNWOROSDVRGCHGAXPJRYOANEUXXCIWCTWONMUJXERKCJOIEJLFSYJEBTXXMXOACOFJDKZVCQNIBXCAXXKJNMRSQNGFXSLRUGJZIJBYNXOIKYHROIEMBRQFQQCICDZNBEGZMCBWFDCFHTXQJKVLYUSCERNBSGIHSMXLMSIEUKWNRIPITALITCVIUNTAFKHGHPICQXNKNJPILSCHAHWGIIZXFCUEHFGYIHOYAEENIYKDEXFIXFDJWNYAHKDYHBITGPDNHYXUPMERQPWXXCZCFQBWHEHTSKVHTSQNIRPWMRZUDWIPGPJXDAIWXINQJCYEVTRQNRPFLUXOYAFLRYDWZITRHWGIOMLSBUOXZVGYCNSOKHXZHKOFOBISCCCSDOBHWQTBCOZCEYHDYXYGTIOWGWDTRSWTXEIOKHPCXFTSDLTJJAWKHTUVWPTSNJNEPSETNUROCISNOKXKTCHQHMAJKGPJXSJIDNLUAOSEFLZVHWOKBAEGBPCWOZYYAXJTKIHFTJEHYGCGHVCCNWHTCZQNIAUQFSLY"
#INPUT_TEXT = "RIARFUFSFMQVGLKSEWXCCOHWHRCRPMYVANBOQFLSQVGEGNFCTSMYQLOJRFUIIEUKVGKIYDQCNMGTCBVHXMVSOIQHOLDIALLFKJJJYWGOQGFBGWBHKQCSEEQYQGXCGBISYAKRFFZIYHMFWZWPGNLCYWPLHSDZMBAUQLAXJSIKZPFLKDJOTMBYHIRHYMJSJPGLYQDPPQZTONHFWDINRYKEXIPDGUYTTTZOAAEZPQQPNZGBBSFUHVHYRGYBTSZYLLMJFIJBOQFLSQVGONKMTWGVYJRXHVFPUXTSIZWVFUONLCZCATDYLHRGEGOQRKPQBULWQKHEVOZQLFDQLAMMHSSUCDYQDGGXMJANCROGLGNNXFJFWFRRYEPLRPJVCQRHZEVJNLLKBAYFVDTBFIPFALNNKMRCJLPEFXSOLNONJWTUWOVIHPMRIPSMHAMYSAWPOQGXNZOEHHZJRPMPMHAMHRVLHZDWDXGVMHMQGFCWUZKVLROQQDLFTZWCUMJRZSIBQISQLQLQYJYNKYZZTRUYRHJVNULFFSAUSIKRZVLZUGPLZYUSMLAIGVDFWDPDETKEQGSLJZWDNBBAUAEHOPODAZATPULVZEXKATQAFMXTAIVBZAAZNVNLEELHFWXTUWYQQRZVJIUSSNPGZGBWDUESMRSCXSAQSWMKLDCVUYAMUIXAARIDTBRWOBZLZEXRCZNMRIALFNILHBIUBPPSRFUATTSZEPLDVZDAFNMMEDXOZZRUUUTZDLAMSQQIJVFELAWAACIKRTXLBDANUKXPHGBAYAQDJPYVXUWNRDYWRUKQKQZNICQUDPWCCKSYQDSTEIMNOGCZNAMXATRKIJPQWGANEJEVMLMQFOTNVYERTCQJYLTZATLTIUFALARHFLLWHZHRHUWGARTHRUBHEUPFXIRFJFKOEKKSQOMZLOOZNAIVAFJOYCIHRBKCFPTJLUIURRLZBNEHFAEF"
#INPUT_TEXT = "DXYBOCOEEYYHUXJAHFKUCKNJSCJXVPWGEQUABKKQTNDSCJXOFMEUCUBORZBCKOXYFTAQHREFSAHCEANZMJLGSJLANTKUYTOWWLZWZGBEGYEHKZSXRXLZMCXDIIEJNJHEVJRVDGWYUOXAZVTYKDVYSHOIEDMQSYGKYJGMNMFHNUIAZCRUZARPGKGCGFIGBFJCXHDNOCSJCVUTXEAGKGGQKKSWVLAZTOXFLUHDPTCRUTDLRGTQVLZKBUOKVSCBFVLGOCDRFAUCKOOTXHDXHRVTSUHFLLRLWTZLDWZRRPKIGKERTHSSGWRMYXHJTGAWADKEEXTWWBBBJKUVGEGQSRYFMEUMNQOSOJEVPWSKRLHTCEZMMKZHFZGLSNERTHFOOHGYORCLESCVCBEQEHNYWSUOXAZVTMMVMRDVVYFQQRLZRVWKQLPXJYNVYGBPUKOITYYRMGBLFYGOQQLZXHCMEZNGYXUQYGYGQLZBTAJILLSVTGHROOOCRGYROJDAPTXVYUAVSPTMLCYIUMKZMGXLHPBDNQZXLTZFQUXFHEFTFMOWMQJYUCDFKXHHVEUFIYUQRZXFGCIJLWSKVIHGEEVYRDFPZPTCBVBLEOXJYCBQKMIYYHZDHHMLRLWTZLXNFZVOUFDDWAUATYMMXMOORIENCGGKFAHMSDQACOAOKWZMVHORJQXCTIRZYIJKIJWHUBJFREUXVMGIRYCYIMNBFFRWTFZUTOBASAHKISGXULNWCTIRDRTDIZKFGVMFHBVSLXPDCNSCSVPSYTDYATUEWPXMMGRTUBAHERBVTWPZGBUJFROKRGSERDLHNFSMMMJBZEVPGJKRCHKKVMRNZQOESBTJRDLTIXDTAGBTJRVRGQLDLKHBGYXWTHKEJRDAHMUHQDRLZZAMAIAMBSTYNDGZQBIBLDQSKWBLGKFGDEVIGTVPNSMUHBVLUBSOXBEUEKOCXHKIBVOULCUXKDRIVLVWYKYWRPVPWGLKQIXXPVCAYQWJXABADMZUMIBPAITWFQZFABWSHKHRUXPCNQKAWKPUBVUTXEAMKVIZXCFAFLRYCWXCUFDYACNQSUCAMZKSOTSOGBOKCPBSYHLFABMPNJYRMLJBLZZFZLFKNJLIIYCTNYMHLSXWZEYRJRGRKGB"
INPUT_TEXT = "JLZMNYAOBCRKCCJMFZHROBJECZGPVJGBAZAWKWRQGCEFVGJYUUPBRGLRJEOORNIDFYTZXHKBSECSQPIXAGCWOWIKVDSGFALVVLOMPXWXRNZBYCIMAERBYXBGPKXSIGCNCFXWHXQSMFZVXVECYMAXYOLBZBRGXNJUSDUVMQCOBHWLTQSXECGEUTOWHIOKLGVHDFHURHMRCHLJOLZKKIVUZYGNASMXSWYONDFNFFMSMQSMWMCWOYMRHHFFRFJWHJFVHLSSINFQJBLCWZIUZXYDDTGVUPQIJFNGJAVZSKBESCSVKNRNWQZHBOMJQCGZYXBDYVEQQMGDFECBMFXJGITVBLUXSEGVQBBNKZYAQMQJSMWCFAZYXVIMQOODVODHGCBCRKWSNEPZNZRDDRHIMEDCWGMTBDSZRJEOZQNVCWIVTJBNKRXVBSRUXVWHBPIQUXFEVBSAUTRBINIIVNLZIRRBPBHOCZEPZNLYQCVBSYEXLCLLUPDZMZDACFZRVQOHOFLZODGEHHDCQHRBABIMSXYNVBTIMEDCVYTPVJKCSSUOULAHCCHTZAHXFDINGBPBHOCZBIMVKATUAQQMSXESHBTELZXDIFSPZHMYFIWGBKGDHJPOYCSKXANPFTDXQDIGDAMYHOQJCQWZKBZIYCZENLJAURPZLZINVPDGNBPNFCADWQZBNBYSPZLGXRYAUPDZKQUACFABHYSLIUQQMDNQGHMAXMQSHMUERXUSXRMXJTXWSLIUMWNOKEAUQQGVQOCVBVGUESFNQQYGMJQEMSAWNOMUGKAPXBCGYTGZHWEHHRGYGABVOFAUZXIDTHRAQQFTPSMISMEXYZTPOERBGJPYAUMILYQJOOEGFTWRHWEMVIKMBROHCNGMFYRPQQZRDDRHIMEDJHQQMTDIMDFGWZEGANZIVHMVZZQEBTADJHAYWPBQQGCOHBCRMSPQONPBXSKXDTJVUJRMQSSEFZHMYMU"
ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
SLOVAK_PROBABILITIES_WITH_SPACE = [0.08945, 0.01124, 0.03372, 0.01124, 0.07596, 0.00266, 0.00222, 0.02050, 0.06590, 0.01920, 0.03172, 0.03189, 0.02539, 0.05324, 0.08511, 0.02538, 0.00000, 0.03789, 0.04969, 0.03265, 0.003202, 0.04057, 0.00011, 0.00047, 0.02322, 0.02628] #, 0.13489]
SLOVAK_PROBABILITIES = [0.11160, 0.01778, 0.02463, 0.03760, 0.09316, 0.00165, 0.00175, 0.02482, 0.05745, 0.02158, 0.03961, 0.04375, 0.03578, 0.05949, 0.09540, 0.03007, 0.00000, 0.04706, 0.06121, 0.05722, 0.03308, 0.04604, 0.00001, 0.00028, 0.02674, 0.03064]
ENGLISH_PROBABILITIES = [0.0856, 0.0139, 0.0279, 0.0378, 0.1304, 0.0289, 0.0199, 0.0526, 0.0627, 0.0019, 0.0042, 0.0339, 0.0249, 0.0707, 0.0707, 0.0797, 0.0199, 0.0012, 0.0977, 0.0607, 0.1045, 0.0249, 0.0092, 0.0149, 0.0017, 0.0199, 0.0008]
KEY_LENGTH = (15, 25)


def frequency_analysis(letters):
    # vypocita vyskyt znakov abecedy v texte (letters)
    probabilities = []
    occurrences = []

    for letter in ALPHABET:
        occurrences.append(letters.count(letter))
    sum_occurrences = sum(occurrences)
    for occurrence in occurrences:
        probabilities.append(occurrence / sum_occurrences)

    return probabilities


def shift_letters(letters, shift_by):
    # posunie pismena (v zozname) o urceny posun - prevod na cislo, pripocitanie posunu, prevod na pismeno
    shifted_letters = []
    if shift_by == 0:
        return letters

    for letter in letters:
        shifted_letter = ord(letter) + shift_by
        if shifted_letter > 90:
            shifted_letters.append(chr(shifted_letter - 26))
        else:
            shifted_letters.append(chr(shifted_letter))
    return shifted_letters


def get_error(probabilities1, probabilities2):
    # vrati chybu medzi dvoma zoznamami pravdepodobnosti
    error_sum = 0
    for i in range(0, len(probabilities1)):
        error_sum += (probabilities1[i] - probabilities2[i])**2

    return error_sum


def compare_coincidence_probabilities(key_length, text_length):
    columns = []

    # rozdelim text do stlpcov podla dlzky kluca
    for i in range(0, key_length):
        sub_column = []
        for y in range(i, text_length - key_length, key_length):
            sub_column.append(INPUT_TEXT[y])
        columns.append(sub_column)

    key = []
    # pre kazdy stlpec pismena posuvam a porovnavam pravdepodobnosti vyskytov so slovenskym jazykom
    # pre kazde porovnanie vypocitam chybu, a posun s najmensou chybou pridavam do kluca
    for sub_column in columns:
        lowest_error = None
        best_shift = None
        for i in range(1, 27):
            shifted_column = shift_letters(sub_column, i)  # posun pismen v stlpci
            # vypocitanie pravdepodobnosti vyskytu vsetkych pismen v danom stlpci
            probabilities = frequency_analysis(shifted_column)
            # vypocet chyby medzi ziskanymi pravdepodobnostami a pravdepodobnostami pre slovensky jazyk z tabulky
            error = get_error(probabilities, SLOVAK_PROBABILITIES)
            if not lowest_error or error < lowest_error:  # po najdeni najmensej chyby urcim posun ako cast kluca
                lowest_error = error
                best_shift = chr(ord('A') + 26 - i)

        key.append(best_shift)

    return key


def get_divisors_of_num(number):
    divisors = []

    # KEY_LENGTH obmedzuje moznu dlzku podla zadania na skratenie vypoctoveho casu
    for i in range(KEY_LENGTH[0], KEY_LENGTH[1] + 1):
        if number % i == 0:
            divisors.append(i)

    return divisors


def kassisk(text):
    length = len(text)
    occurrences_dict = {}

    # prechadzam text a hladam totozne trojice pismen a vzdialenost medzi nimi
    for i in range(0, length - 3):
        for y in range(i + 1, length - 3):
            if text[i:i+3] == text[y:y+3]:
                if str(y - i) in occurrences_dict.keys():
                    occurrences_dict[str(y - i)] += 1
                else:
                    occurrences_dict[str(y - i)] = 1
                continue

    # usporiadanie slovnika zostupne
    sorted_occurrence_dict_descending = {k: v for k, v in sorted(occurrences_dict.items(), key=lambda item: item[1], reverse=True)}

    # ulozenie usporiadanych hodnot zo slovnika do zoznamu
    occurrences_list = []
    for key, value in sorted_occurrence_dict_descending.items():
        occurrences_list.append(key)
    return occurrences_list


def decrypt(text, key):
    decrypted_message = ""
    for i in range(0, len(text)):
        key_index = i % len(key)

        # odcitam kluc od zasifrovaneho textu
        shifted_letter = ord(text[i]) - ord(key[key_index]) + 65
        if shifted_letter < 65:
            shifted_letter += 26
        shifted_letter = chr(shifted_letter)
        decrypted_message += shifted_letter

    return decrypted_message


def main():
    keys = []
    used_divisors = []

    # vykonam kassiskeho analyzu pre trojice, funkcia vrati zostupne usporiadany zoznam poctov medzier medzi trojicami
    occurrences = kassisk(INPUT_TEXT)
    for i in range(0, len(occurrences)): #  zacnem prechadzat najdene vzdialenosti medzi trojicami
        value = occurrences.pop(0) #  vytiahnem prvu hodnotu
        divisors = get_divisors_of_num(int(value)) #  vrati vzostupne usporiadany zoznam delitelov
        if not divisors:
            continue

        for divisor in divisors: #  prechadzam najdenych delitelov - mozne dlzky kluca
            if divisor in used_divisors: #  preskocim duplicitne hodnoty delitelov
                continue
            used_divisors.append(divisor)

            # ziskam kluc
            # rozdelim si text do stlpcov (aby boli monoalfabeticke), posuvam ich a hladam chybu (metoda najmensich stvorcov)
            key = compare_coincidence_probabilities(divisor, len(INPUT_TEXT))
            keys.append(key)

    # odsifrovanie spravy a vypis
    index = 1
    for key in keys:
        #key[8] = chr(ord(key[8]) - 4)
        decrypted_message = decrypt(INPUT_TEXT, key)  # odsifrovanie spravy
        print(f"{index}. kluc => {''.join(key)}")
        print(f"sprava => {decrypted_message}")
        index += 1


if __name__ == "__main__":
    main()
